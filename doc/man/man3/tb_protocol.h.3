.TH "src/tb_protocol.h" 3 "Wed Feb 12 2014" "Version 0.2" "TestBed" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/tb_protocol.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'tb_epoll\&.h'\fP
.br
\fC#include <sys/socket\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBtb_protocol_t\fP"
.br
.RI "\fIDefines the API for the chosen protocol\&. \fP"
.ti -1c
.RI "struct \fBtb_prot_stats_t\fP"
.br
.RI "\fIProtocol information struct\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int(* \fBfunct_socket\fP )(int domain, int type, int protocol)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_close\fP )(int fd)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_bind\fP )(int fd, const struct sockaddr *addr, socklen_t len)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_connect\fP )(int fd, const struct sockaddr *addr, socklen_t len)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_send\fP )(int fd, void *buf, size_t n, int sock_flags)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_recv\fP )(int fd, void *buf, size_t n, int sock_flags)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_listen\fP )(int fd, int n)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_accept\fP )(int fd, const struct sockaddr *addr, socklen_t *len)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_sendto\fP )(int fd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_recvfrom\fP )(int fd, void *buf, int len, unsigned int flags, const struct sockaddr *to, socklen_t *tolen)"
.br
.ti -1c
.RI "typedef void(* \fBfunct_exit\fP )()"
.br
.ti -1c
.RI "typedef int(* \fBfunct_error\fP )(int value, int err_no)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_options\fP )(int sock, int level, int optname, void *optval, int optlen)"
.br
.ti -1c
.RI "typedef int(* \fBfunct_setup\fP )(void *data)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBPROTOCOL\fP { \fBTCP\fP =  0, \fBUDP\fP =  1, \fBUDT\fP =  2, \fBaUDT\fP =  3, \fBuTP\fP =  4, \fBeUDP\fP =  5, \fBDCCP\fP =  6 }"
.br
.ti -1c
.RI "enum \fBCONGESTION_CONTROL\fP { \fBTCP_VEGAS\fP =  1, \fBTCP_CUBIC\fP, \fBUDT_DAIMID\fP, \fBUDT_ADAPTIVE\fP, \fBUDP_NONE\fP }"
.br
.ti -1c
.RI "enum \fBPROT_OPT\fP { \fBUSE_BLOCKING\fP, \fBUSE_EPOLL\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBtb_destroy_stats\fP (\fBtb_prot_stats_t\fP *stats)"
.br
.RI "\fIDestroy stats struct\&. \fP"
.ti -1c
.RI "int \fBtb_udt_error\fP (int value, int err_no)"
.br
.RI "\fIHandle errors for udt\&. \fP"
.ti -1c
.RI "int \fBtb_dccp_error\fP (int value, int err_no)"
.br
.RI "\fIHandle errors for dccp\&. \fP"
.ti -1c
.RI "int \fBtb_socket_error\fP (int value, int err_no)"
.br
.RI "\fIHandle errors for socket\&. \fP"
.ti -1c
.RI "void \fBtb_get_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet the stats for the given protocol, with the given descriptor\&. \fP"
.ti -1c
.RI "void \fBget_udt_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet udt stats\&. \fP"
.ti -1c
.RI "void \fBget_dccp_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet dccp stats\&. \fP"
.ti -1c
.RI "void \fBget_tcp_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet tcp stats\&. \fP"
.ti -1c
.RI "void \fBget_udp_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet udp stats\&. \fP"
.ti -1c
.RI "void \fBget_utp_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet utp stats\&. \fP"
.ti -1c
.RI "void \fBtb_get_bsd_stats\fP (\fBtb_prot_stats_t\fP *stats, int fd)"
.br
.RI "\fIGet generic bsd stats\&. \fP"
.ti -1c
.RI "\fBtb_protocol_t\fP * \fBtb_create_protocol\fP (\fBPROTOCOL\fP prot)"
.br
.RI "\fICreate a new Protocol\&. \fP"
.ti -1c
.RI "void \fBtb_destroy_protocol\fP (\fBtb_protocol_t\fP *protocol)"
.br
.RI "\fIDestroy the given protocol structure\&. \fP"
.ti -1c
.RI "void \fBtb_print_protocol\fP (\fBtb_protocol_t\fP *protocol)"
.br
.RI "\fIPrint the values for this protocol\&. \fP"
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef int(* funct_accept)(int fd, const struct sockaddr *addr, socklen_t *len)"

.PP
Definition at line 107 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_bind)(int fd, const struct sockaddr *addr, socklen_t len)"

.PP
Definition at line 77 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_close)(int fd)"

.PP
Definition at line 71 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_connect)(int fd, const struct sockaddr *addr, socklen_t len)"

.PP
Definition at line 83 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_error)(int value, int err_no)"

.PP
Definition at line 133 of file tb_protocol\&.h\&.
.SS "typedef void(* funct_exit)()"

.PP
Definition at line 127 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_listen)(int fd, int n)"

.PP
Definition at line 101 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_options)(int sock, int level, int optname, void *optval, int optlen)"

.PP
Definition at line 139 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_recv)(int fd, void *buf, size_t n, int sock_flags)"

.PP
Definition at line 95 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_recvfrom)(int fd, void *buf, int len, unsigned int flags, const struct sockaddr *to, socklen_t *tolen)"

.PP
Definition at line 120 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_send)(int fd, void *buf, size_t n, int sock_flags)"

.PP
Definition at line 89 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_sendto)(int fd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)"

.PP
Definition at line 113 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_setup)(void *data)"

.PP
Definition at line 146 of file tb_protocol\&.h\&.
.SS "typedef int(* funct_socket)(int domain, int type, int protocol)"

.PP
Definition at line 65 of file tb_protocol\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBCONGESTION_CONTROL\fP"

.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fITCP_VEGAS \fP\fP
The TCP vegas control algorithm\&. 
.TP
\fB\fITCP_CUBIC \fP\fP
The TCP CUBIC control algorithm\&. 
.TP
\fB\fIUDT_DAIMID \fP\fP
UDT's default control algorithm\&. 
.TP
\fB\fIUDT_ADAPTIVE \fP\fP
The new algorithm added to UDT\&. 
.TP
\fB\fIUDP_NONE \fP\fP
UDP does not use congestion control\&. 
.PP
Definition at line 39 of file tb_protocol\&.h\&.
.SS "enum \fBPROT_OPT\fP"

.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIUSE_BLOCKING \fP\fP
Use standard blocking sockets\&. 
.TP
\fB\fIUSE_EPOLL \fP\fP
Use Epoll for sockets\&. 
.PP
Definition at line 54 of file tb_protocol\&.h\&.
.SS "enum \fBPROTOCOL\fP"

.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fITCP \fP\fP
Regular, garden variety TCP\&. Yawn\&. 
.TP
\fB\fIUDP \fP\fP
Regular, garden variety UDP\&. 
.TP
\fB\fIUDT \fP\fP
Flash and fun UDT, please\&. 
.TP
\fB\fIaUDT \fP\fP
Yet to be implemented adaptive UDT\&. 
.TP
\fB\fIuTP \fP\fP
Arrrr a pirates favourite protocol\&. 
.TP
\fB\fIeUDP \fP\fP
UDP with epoll\&. 
.TP
\fB\fIDCCP \fP\fP
DCCP, in linux kernal\&. 
.PP
Definition at line 21 of file tb_protocol\&.h\&.
.SH "Function Documentation"
.PP 
.SS "void get_dccp_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get dccp stats\&. 
.PP
Definition at line 299 of file tb_protocol\&.c\&.
.SS "void get_tcp_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get tcp stats\&. 
.PP
Definition at line 305 of file tb_protocol\&.c\&.
.SS "void get_udp_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get udp stats\&. 
.PP
Definition at line 287 of file tb_protocol\&.c\&.
.SS "void get_udt_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get udt stats\&. 
.PP
Definition at line 258 of file tb_protocol\&.c\&.
.SS "void get_utp_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get utp stats\&. 
.PP
Definition at line 293 of file tb_protocol\&.c\&.
.SS "\fBtb_protocol_t\fP* tb_create_protocol (\fBPROTOCOL\fPprot)"

.PP
Create a new Protocol\&. Creates the protocol, and loads the struct with all of the relevant functions to perform communication\&.
.PP
\fBPrecondition:\fP
.RS 4
The protocol must be one of the supported types\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprot\fP The protocol to use in the tests\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The struct \fBtb_protocol_t\fP 
.RE
.PP

.PP
Definition at line 27 of file tb_protocol\&.c\&.
.SS "int tb_dccp_error (intvalue, interr_no)"

.PP
Handle errors for dccp\&. 
.PP
Definition at line 192 of file tb_protocol\&.c\&.
.SS "void tb_destroy_protocol (\fBtb_protocol_t\fP *protocol)"

.PP
Destroy the given protocol structure\&. Destroys the struct, freeing up memory\&.
.PP
\fBPrecondition:\fP
.RS 4
protocol must be of type \fBtb_protocol_t\fP\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprotocol\fP The struct to destroy\&. 
.RE
.PP

.PP
Definition at line 344 of file tb_protocol\&.c\&.
.SS "void tb_destroy_stats (\fBtb_prot_stats_t\fP *stats)"

.PP
Destroy stats struct\&. 
.PP
Definition at line 247 of file tb_protocol\&.c\&.
.SS "void tb_get_bsd_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get generic bsd stats\&. 
.PP
Definition at line 334 of file tb_protocol\&.c\&.
.SS "void tb_get_stats (\fBtb_prot_stats_t\fP *stats, intfd)"

.PP
Get the stats for the given protocol, with the given descriptor\&. 
.PP
Definition at line 215 of file tb_protocol\&.c\&.
.SS "void tb_print_protocol (\fBtb_protocol_t\fP *protocol)"

.PP
Print the values for this protocol\&. \fBParameters:\fP
.RS 4
\fIlistener\fP The protocol to print the values for\&. 
.RE
.PP

.PP
Definition at line 209 of file tb_protocol\&.c\&.
.SS "int tb_socket_error (intvalue, interr_no)"

.PP
Handle errors for socket\&. 
.PP
Definition at line 185 of file tb_protocol\&.c\&.
.SS "int tb_udt_error (intvalue, interr_no)"

.PP
Handle errors for udt\&. 
.PP
Definition at line 203 of file tb_protocol\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for TestBed from the source code\&.
