.TH "src/tb_listener.h" 3 "Wed Feb 12 2014" "Version 0.2" "TestBed" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/tb_listener.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'tb_protocol\&.h'\fP
.br
\fC#include 'tb_epoll\&.h'\fP
.br
\fC#include 'tb_worker\&.h'\fP
.br
\fC#include 'tb_logging\&.h'\fP
.br
\fC#include 'tb_session\&.h'\fP
.br
\fC#include 'tb_sock_opt\&.h'\fP
.br
\fC#include <gdsl/gdsl_hash\&.h>\fP
.br
\fC#include <gdsl/gdsl_heap\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <glib-2\&.0/glib/ghash\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBtb_test_params_t\fP"
.br
.RI "\fIstruct used to pass parameters into testbed\&. \fP"
.ti -1c
.RI "struct \fBtb_listener_t\fP"
.br
.RI "\fIstruct that defines the fields for the listener class\&. \fP"
.ti -1c
.RI "struct \fBtb_other_info\fP"
.br
.RI "\fIstruct that contains information on the current status of the listener\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBfunct_l_exit\fP )(void *listener)"
.br
.ti -1c
.RI "typedef void(* \fBfunct_l_abort\fP )(void *listener)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBENDPOINT_TYPE\fP { \fBSERVER\fP =  0, \fBCLIENT\fP, \fBmSERVER\fP, \fBmCLIENT\fP }"
.br
.RI "\fIThe type of endpoint to create\&. \fP"
.ti -1c
.RI "enum \fBSTATUS\fP { \fBTB_CREATED\fP =  0, \fBTB_STARTING\fP =  1, \fBTB_CONNECTED\fP =  2, \fBTB_DISCONNECTED\fP =  3, \fBTB_LISTENING\fP =  4, \fBTB_EXITING\fP =  5, \fBTB_ABORTING\fP =  6, \fBTB_POLLING\fP =  7 }"
.br
.ti -1c
.RI "enum \fBCOMMAND\fP { \fBTB_CONTINUE\fP =  1, \fBTB_ABORT\fP =  2, \fBTB_EXIT\fP =  4, \fBTB_E_LOOP\fP =  TB_ABORT | TB_EXIT }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBtb_set_l_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIGets the stats for the listener\&. \fP"
.ti -1c
.RI "void \fBtb_set_m_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIGets the stats for the listener\&. \fP"
.ti -1c
.RI "\fBtb_prot_stats_t\fP * \fBtb_ex_get_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIA thread safe way to get access to stats\&. \fP"
.ti -1c
.RI "\fBtb_listener_t\fP * \fBtb_create_listener\fP (\fBENDPOINT_TYPE\fP type, char *addr, char *port, \fBPROTOCOL\fP protocol, int bufsize)"
.br
.RI "\fICreate a listener with the supplied parameters\&. \fP"
.ti -1c
.RI "\fBtb_listener_t\fP * \fBtb_create_endpoint\fP (\fBtb_test_params_t\fP *params)"
.br
.RI "\fICreate a listener using a \fBtb_test_params_t\fP struct\&. \fP"
.ti -1c
.RI "\fBtb_worker_t\fP * \fBtb_get_worker\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"
.br
.RI "\fIGet a worker for the supplied session\&. \fP"
.ti -1c
.RI "void \fBtb_destroy_listener\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIDestroy a listener\&. \fP"
.ti -1c
.RI "int \fBtb_set_therad_param\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fISet the affinity and scheduling priority for a given thread\&. \fP"
.ti -1c
.RI "void \fBtb_get_cpu_info\fP (\fBtb_listener_t\fP *listener)"
.br
.ti -1c
.RI "void \fBtb_print_listener\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIPrint a listener\&. \fP"
.ti -1c
.RI "int \fBtb_resolve_address\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIResolve the address for the given listener\&. \fP"
.ti -1c
.RI "int \fBtb_set_sockopt\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fISet sockopt\&. \fP"
.ti -1c
.RI "int \fBtb_create_socket\fP (\fBtb_listener_t\fP *listener) __attribute__((always_inline))"
.br
.RI "\fICreate a socket\&. \fP"
.ti -1c
.RI "int \fBtb_listen\fP (\fBtb_listener_t\fP *listener) __attribute__((always_inline))"
.br
.RI "\fIBind and listen\&. \fP"
.ti -1c
.RI "\fBtb_session_t\fP * \fBtb_accept\fP (\fBtb_listener_t\fP *listener) __attribute__((always_inline)) __attribute__((deprecated))"
.br
.RI "\fIAccept an incoming connection\&. \fP"
.ti -1c
.RI "int \fBtb_connect\fP (\fBtb_listener_t\fP *listener) __attribute__((always_inline))"
.br
.RI "\fIAttempt to connect\&. \fP"
.ti -1c
.RI "int \fBtb_bind\fP (\fBtb_listener_t\fP *listener) __attribute__((always_inline))"
.br
.RI "\fIBind the listener to its address\&. \fP"
.ti -1c
.RI "int \fBtb_send_data\fP (\fBtb_listener_t\fP *listener, char *buff, int size) __attribute__((always_inline))"
.br
.RI "\fISend data\&. \fP"
.ti -1c
.RI "int \fBtb_recv_data\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session) __attribute__((always_inline))"
.br
.RI "\fIReceive data\&. \fP"
.ti -1c
.RI "int \fBtb_send_to\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session) __attribute__((always_inline))"
.br
.ti -1c
.RI "int \fBtb_recv_from\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session) __attribute__((always_inline))"
.br
.RI "\fIrecv from - used by UDP\&. \fP"
.ti -1c
.RI "void \fBtb_get_prot_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIcollect stats for listener\&. \fP"
.ti -1c
.RI "int \fBtb_set_epoll\fP (\fBtb_listener_t\fP *listener) __attribute__((always_inline))"
.br
.RI "\fISet epoll for this listener\&. \fP"
.ti -1c
.RI "void \fBtb_error\fP (\fBtb_listener_t\fP *listener, const char *info, int errno) __attribute__((always_inline))"
.br
.RI "\fIFormat an error to the log file\&. \fP"
.ti -1c
.RI "void \fBtb_address\fP (\fBtb_listener_t\fP *listener, const char *info, struct sockaddr_storage *store) __attribute__((always_inline))"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* funct_l_abort)(void *listener)"

.PP
Definition at line 129 of file tb_listener\&.h\&.
.SS "typedef void(* funct_l_exit)(void *listener)"

.PP
Definition at line 123 of file tb_listener\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBCOMMAND\fP"

.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fITB_CONTINUE \fP\fP
Regular status\&. 
.TP
\fB\fITB_ABORT \fP\fP
Abort the current operation\&. 
.TP
\fB\fITB_EXIT \fP\fP
Exit from the current operation\&. 
.TP
\fB\fITB_E_LOOP \fP\fP
Exit from loop\&. 
.PP
Definition at line 64 of file tb_listener\&.h\&.
.SS "enum \fBENDPOINT_TYPE\fP"

.PP
The type of endpoint to create\&. .RS 4
[\fBtb_listener\&.h\fP] 
.RE
.PP

.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fISERVER \fP\fP
The listener is a server\&. 
.TP
\fB\fICLIENT \fP\fP
The listener is a client\&. 
.TP
\fB\fImSERVER \fP\fP
Multi connection server\&. 
.TP
\fB\fImCLIENT \fP\fP
Multi connection client\&. 
.PP
Definition at line 32 of file tb_listener\&.h\&.
.SS "enum \fBSTATUS\fP"
.RS 4
[\fBtb_listener\&.h\fP]
.PP
.RE
.PP
.PP
Specifies the current state of the testbed\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fITB_CREATED \fP\fP
The listener has been created\&. 
.TP
\fB\fITB_STARTING \fP\fP
The listener is starting up\&. 
.TP
\fB\fITB_CONNECTED \fP\fP
The listener is connected\&. 
.TP
\fB\fITB_DISCONNECTED \fP\fP
The listener is disconnected\&. 
.TP
\fB\fITB_LISTENING \fP\fP
The listener is listening for incoming connections\&. 
.TP
\fB\fITB_EXITING \fP\fP
The listener is exiting\&. 
.TP
\fB\fITB_ABORTING \fP\fP
The listener is aborting\&. 
.TP
\fB\fITB_POLLING \fP\fP
The listener is polling\&. 
.PP
Definition at line 46 of file tb_listener\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBtb_session_t\fP* tb_accept (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Accept an incoming connection\&. Accepts incoming connections\&. This operation blocks, as we are using blocking I/O currently\&.
.PP
\fBDeprecated\fP
.RS 4
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to accept the connection on\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtb_session_t\fP A newly created session\&. 
.RE
.PP

.PP
Definition at line 467 of file tb_listener\&.c\&.
.SS "void tb_address (\fBtb_listener_t\fP *listener, const char *info, struct sockaddr_storage *store)\fC [inline]\fP"

.PP
Definition at line 692 of file tb_listener\&.c\&.
.SS "int tb_bind (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Bind the listener to its address\&. Binds the listener to the address specified by address\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to bind\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on failure\&. 
.RE
.PP

.PP
Definition at line 564 of file tb_listener\&.c\&.
.SS "int tb_connect (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Attempt to connect\&. Attempts to connect to the specified address and port\&. 
.PP
Definition at line 545 of file tb_listener\&.c\&.
.SS "\fBtb_listener_t\fP* tb_create_endpoint (\fBtb_test_params_t\fP *params)"

.PP
Create a listener using a \fBtb_test_params_t\fP struct\&. The details in the struct are used to create an endpoint for use in testing\&.
.PP
\fBParameters:\fP
.RS 4
\fIparams\fP A struct with all of the required details for a test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the endpoint to test with\&. 
.RE
.PP

.PP
Definition at line 158 of file tb_listener\&.c\&.
.SS "\fBtb_listener_t\fP* tb_create_listener (\fBENDPOINT_TYPE\fPtype, char *addr, char *port, \fBPROTOCOL\fPprotocol, intbufsize)"

.PP
Create a listener with the supplied parameters\&. Creates a listener and the accociated data structures\&.
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The type of endpoint to create\&. 
.br
\fIaddr\fP The address to bind to\&. 
.br
\fIport\fP The port to bind to\&. 
.br
\fInum_threads\fP The number of worker threads to use\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The newly created listener\&. 
.RE
.PP

.PP
Definition at line 38 of file tb_listener\&.c\&.
.SS "int tb_create_socket (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Create a socket\&. Creates a new socket for the specified listener\&.
.PP
\fBParameters:\fP
.RS 4
\fIThe\fP listener to create the socket for\&. 
.RE
.PP

.PP
Definition at line 527 of file tb_listener\&.c\&.
.SS "void tb_destroy_listener (\fBtb_listener_t\fP *listener)"

.PP
Destroy a listener\&. Destroys the listener, and its associated data structures\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to destroy\&. 
.RE
.PP

.PP
Definition at line 282 of file tb_listener\&.c\&.
.SS "void tb_error (\fBtb_listener_t\fP *listener, const char *info, interrno)\fC [inline]\fP"

.PP
Format an error to the log file\&. 
.PP
Definition at line 676 of file tb_listener\&.c\&.
.SS "\fBtb_prot_stats_t\fP* tb_ex_get_stats (\fBtb_listener_t\fP *listener)"

.PP
A thread safe way to get access to stats\&. This method controls access to the stats generated by testbed\&. These stats are updated every second, and can be read once\&. If the data that can be obtained by this function has already been read, it blocks until new data has arrived\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener for which to get the stats from\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtb_prot_stats_t\fP with the stats inserted\&. 
.RE
.PP

.PP
Definition at line 362 of file tb_listener\&.c\&.
.SS "void tb_get_cpu_info (\fBtb_listener_t\fP *listener)"
Gets the tid from syscall and pthread_self, sets them in the listener\&. 
.PP
Definition at line 276 of file tb_listener\&.c\&.
.SS "void tb_get_prot_stats (\fBtb_listener_t\fP *listener)"

.PP
collect stats for listener\&. 
.SS "\fBtb_worker_t\fP* tb_get_worker (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"

.PP
Get a worker for the supplied session\&. Fetches a worker to perform work based on the information contained in the \fBtb_session_t\fP struct\&. If no such session exists (when a new connection is created) then this session will be added to the hashtable, and assigned a worker\&. 
.PP
Definition at line 244 of file tb_listener\&.c\&.
.SS "int tb_listen (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Bind and listen\&. Binds the listener to the specified port and ip address, and then begins listening\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to listen\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 
.RE
.PP

.PP
Definition at line 449 of file tb_listener\&.c\&.
.SS "void tb_print_listener (\fBtb_listener_t\fP *listener)"

.PP
Print a listener\&. Prints the given listener to stdout\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to print the values for\&. 
.RE
.PP

.PP
Definition at line 338 of file tb_listener\&.c\&.
.SS "int tb_recv_data (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)\fC [inline]\fP"

.PP
Receive data\&. 
.PP
Definition at line 606 of file tb_listener\&.c\&.
.SS "int tb_recv_from (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)\fC [inline]\fP"

.PP
recv from - used by UDP\&. 
.PP
Definition at line 643 of file tb_listener\&.c\&.
.SS "int tb_resolve_address (\fBtb_listener_t\fP *listener)"

.PP
Resolve the address for the given listener\&. \fBParameters:\fP
.RS 4
\fIlistener\fP The listener to resolve the address for\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if there was no error, -1 otherwise\&. 
.RE
.PP

.PP
Definition at line 497 of file tb_listener\&.c\&.
.SS "int tb_send_data (\fBtb_listener_t\fP *listener, char *buff, intsize)\fC [inline]\fP"

.PP
Send data\&. 
.PP
Definition at line 582 of file tb_listener\&.c\&.
.SS "int tb_send_to (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)\fC [inline]\fP"

.PP
Definition at line 626 of file tb_listener\&.c\&.
.SS "int tb_set_epoll (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Set epoll for this listener\&. 
.PP
Definition at line 659 of file tb_listener\&.c\&.
.SS "void tb_set_l_stats (\fBtb_listener_t\fP *listener)"

.PP
Gets the stats for the listener\&. This method collects the stats for single connection servers\&. The stats are saved in the listener->stats field\&.
.PP
\fBPrecondition:\fP
.RS 4
The listener must be of a single connection type\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to collect stats for\&. 
.RE
.PP

.PP
Definition at line 383 of file tb_listener\&.c\&.
.SS "void tb_set_m_stats (\fBtb_listener_t\fP *listener)"

.PP
Gets the stats for the listener\&. This method collects the stats for multiple connection servers\&. The stats are saved in each of the sessions stats structs, and the total number of bytes sent are saved in the listener->stats struct\&.
.PP
\fBPrecondition:\fP
.RS 4
The listener must be of the multiple connection type\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to collect stats for\&. 
.RE
.PP

.PP
Definition at line 417 of file tb_listener\&.c\&.
.SS "int tb_set_sockopt (\fBtb_listener_t\fP *listener)"

.PP
Set sockopt\&. Set the sockoptions for the given listener\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to set the sockopts for 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 on error, 0 otherwise\&. 
.RE
.PP

.SS "int tb_set_therad_param (\fBtb_listener_t\fP *listener)"

.PP
Set the affinity and scheduling priority for a given thread\&. This sets the affinity for a thread 
.SH "Author"
.PP 
Generated automatically by Doxygen for TestBed from the source code\&.
