.TH "src/tb_listener.c" 3 "Mon Feb 10 2014" "Version 0.2" "TestBed" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/tb_listener.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'tb_listener\&.h'\fP
.br
\fC#include 'tb_worker_pair\&.h'\fP
.br
\fC#include 'tb_protocol\&.h'\fP
.br
\fC#include 'tb_common\&.h'\fP
.br
\fC#include 'tb_worker\&.h'\fP
.br
\fC#include 'tb_logging\&.h'\fP
.br
\fC#include 'tb_sock_opt\&.h'\fP
.br
\fC#include 'tb_session\&.h'\fP
.br
\fC#include <gdsl/gdsl_heap\&.h>\fP
.br
\fC#include <gdsl/gdsl_hash\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <netdb\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/epoll\&.h>\fP
.br
\fC#include <udt\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/syscall\&.h>\fP
.br
\fC#include <sys/sysinfo\&.h>\fP
.br
\fC#include <glib-2\&.0/glib\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBtb_listener_t\fP * \fBtb_create_listener\fP (\fBENDPOINT_TYPE\fP type, char *addr, char *port, \fBPROTOCOL\fP protocol, int bufsize)"
.br
.RI "\fICreate a listener with the supplied parameters\&. \fP"
.ti -1c
.RI "\fBtb_listener_t\fP * \fBtb_create_endpoint\fP (\fBtb_test_params_t\fP *params)"
.br
.RI "\fICreate a listener using a \fBtb_test_params_t\fP struct\&. \fP"
.ti -1c
.RI "int \fBtb_setup_workers\fP (\fBtb_listener_t\fP *listener, int num_threads)"
.br
.ti -1c
.RI "\fBtb_worker_t\fP * \fBtb_get_worker\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"
.br
.RI "\fIGet a worker for the supplied session\&. \fP"
.ti -1c
.RI "\fBtb_worker_t\fP * \fBtb_get_session\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"
.br
.ti -1c
.RI "void \fBtb_get_cpu_info\fP (\fBtb_listener_t\fP *listener)"
.br
.ti -1c
.RI "void \fBtb_destroy_listener\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIDestroy a listener\&. \fP"
.ti -1c
.RI "void \fBtb_print_listener\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIPrint a listener\&. \fP"
.ti -1c
.RI "\fBtb_prot_stats_t\fP * \fBtb_ex_get_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIA thread safe way to get access to stats\&. \fP"
.ti -1c
.RI "void \fBtb_set_l_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIGets the stats for the listener\&. \fP"
.ti -1c
.RI "void \fBtb_set_m_stats\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIGets the stats for the listener\&. \fP"
.ti -1c
.RI "int \fBtb_listen\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIBind and listen\&. \fP"
.ti -1c
.RI "\fBtb_session_t\fP * \fBtb_accept\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIAccept an incoming connection\&. \fP"
.ti -1c
.RI "\fBtb_session_t\fP * \fBtb_epoll_accept\fP (\fBtb_listener_t\fP *listener)"
.br
.ti -1c
.RI "int \fBtb_resolve_address\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIResolve the address for the given listener\&. \fP"
.ti -1c
.RI "int \fBtb_create_socket\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fICreate a socket\&. \fP"
.ti -1c
.RI "int \fBtb_connect\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIAttempt to connect\&. \fP"
.ti -1c
.RI "int \fBtb_bind\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fIBind the listener to its address\&. \fP"
.ti -1c
.RI "int \fBtb_send_data\fP (\fBtb_listener_t\fP *listener, char *buff, int size)"
.br
.RI "\fISend data\&. \fP"
.ti -1c
.RI "int \fBtb_recv_data\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"
.br
.RI "\fIReceive data\&. \fP"
.ti -1c
.RI "int \fBtb_send_to\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"
.br
.ti -1c
.RI "int \fBtb_recv_from\fP (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"
.br
.RI "\fIrecv from - used by UDP\&. \fP"
.ti -1c
.RI "int \fBtb_set_epoll\fP (\fBtb_listener_t\fP *listener)"
.br
.RI "\fISet epoll for this listener\&. \fP"
.ti -1c
.RI "void \fBtb_error\fP (\fBtb_listener_t\fP *listener, const char *info, int err_no)"
.br
.RI "\fIFormat an error to the log file\&. \fP"
.ti -1c
.RI "void \fBtb_address\fP (\fBtb_listener_t\fP *listener, const char *info, struct sockaddr_storage *store)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBtb_session_t\fP* tb_accept (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Accept an incoming connection\&. Accepts incoming connections\&. This operation blocks, as we are using blocking I/O currently
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to accept the connection on\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtb_session_t\fP A newly created session\&. 
.RE
.PP

.PP
Definition at line 466 of file tb_listener\&.c\&.
.SS "void tb_address (\fBtb_listener_t\fP *listener, const char *info, struct sockaddr_storage *store)\fC [inline]\fP"

.PP
Definition at line 692 of file tb_listener\&.c\&.
.SS "int tb_bind (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Bind the listener to its address\&. Binds the listener to the address specified by address\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to bind\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on failure\&. 
.RE
.PP

.PP
Definition at line 564 of file tb_listener\&.c\&.
.SS "int tb_connect (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Attempt to connect\&. Attempts to connect to the specified address and port\&. 
.PP
Definition at line 545 of file tb_listener\&.c\&.
.SS "\fBtb_listener_t\fP* tb_create_endpoint (\fBtb_test_params_t\fP *params)"

.PP
Create a listener using a \fBtb_test_params_t\fP struct\&. The details in the struct are used to create an endpoint for use in testing\&.
.PP
\fBParameters:\fP
.RS 4
\fIparams\fP A struct with all of the required details for a test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the endpoint to test with\&. 
.RE
.PP

.PP
Definition at line 158 of file tb_listener\&.c\&.
.SS "\fBtb_listener_t\fP* tb_create_listener (\fBENDPOINT_TYPE\fPtype, char *addr, char *port, \fBPROTOCOL\fPprotocol, intbufsize)"

.PP
Create a listener with the supplied parameters\&. Creates a listener and the accociated data structures\&.
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The type of endpoint to create\&. 
.br
\fIaddr\fP The address to bind to\&. 
.br
\fIport\fP The port to bind to\&. 
.br
\fInum_threads\fP The number of worker threads to use\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The newly created listener\&. 
.RE
.PP

.PP
Definition at line 38 of file tb_listener\&.c\&.
.SS "int tb_create_socket (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Create a socket\&. Creates a new socket for the specified listener\&.
.PP
\fBParameters:\fP
.RS 4
\fIThe\fP listener to create the socket for\&. 
.RE
.PP

.PP
Definition at line 527 of file tb_listener\&.c\&.
.SS "void tb_destroy_listener (\fBtb_listener_t\fP *listener)"

.PP
Destroy a listener\&. Destroys the listener, and its associated data structures\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to destroy\&. 
.RE
.PP

.PP
Definition at line 282 of file tb_listener\&.c\&.
.SS "\fBtb_session_t\fP* tb_epoll_accept (\fBtb_listener_t\fP *listener)"

.PP
Definition at line 487 of file tb_listener\&.c\&.
.SS "void tb_error (\fBtb_listener_t\fP *listener, const char *info, interr_no)\fC [inline]\fP"

.PP
Format an error to the log file\&. 
.PP
Definition at line 676 of file tb_listener\&.c\&.
.SS "\fBtb_prot_stats_t\fP* tb_ex_get_stats (\fBtb_listener_t\fP *listener)"

.PP
A thread safe way to get access to stats\&. This method controls access to the stats generated by testbed\&. These stats are updated every second, and can be read once\&. If the data that can be obtained by this function has already been read, it blocks until new data has arrived\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener for which to get the stats from\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBtb_prot_stats_t\fP with the stats inserted\&. 
.RE
.PP

.PP
Definition at line 362 of file tb_listener\&.c\&.
.SS "void tb_get_cpu_info (\fBtb_listener_t\fP *listener)"
Gets the tid from syscall and pthread_self, sets them in the listener\&. 
.PP
Definition at line 276 of file tb_listener\&.c\&.
.SS "\fBtb_worker_t\fP* tb_get_session (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"

.PP
Definition at line 270 of file tb_listener\&.c\&.
.SS "\fBtb_worker_t\fP* tb_get_worker (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)"

.PP
Get a worker for the supplied session\&. 
.PP
Definition at line 244 of file tb_listener\&.c\&.
.SS "int tb_listen (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Bind and listen\&. Binds the listener to the specified port and ip address, and then begins listening\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to listen\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 
.RE
.PP

.PP
Definition at line 448 of file tb_listener\&.c\&.
.SS "void tb_print_listener (\fBtb_listener_t\fP *listener)"

.PP
Print a listener\&. Prints the given listener\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to print the values for\&. 
.RE
.PP

.PP
Definition at line 338 of file tb_listener\&.c\&.
.SS "int tb_recv_data (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)\fC [inline]\fP"

.PP
Receive data\&. 
.PP
Definition at line 606 of file tb_listener\&.c\&.
.SS "int tb_recv_from (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)\fC [inline]\fP"

.PP
recv from - used by UDP\&. 
.PP
Definition at line 643 of file tb_listener\&.c\&.
.SS "int tb_resolve_address (\fBtb_listener_t\fP *listener)"

.PP
Resolve the address for the given listener\&. \fBParameters:\fP
.RS 4
\fIlistener\fP The listener to resolve the address for\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 if there was no error, -1 otherwise\&. 
.RE
.PP

.PP
Definition at line 497 of file tb_listener\&.c\&.
.SS "int tb_send_data (\fBtb_listener_t\fP *listener, char *buff, intsize)\fC [inline]\fP"

.PP
Send data\&. 
.PP
Definition at line 582 of file tb_listener\&.c\&.
.SS "int tb_send_to (\fBtb_listener_t\fP *listener, \fBtb_session_t\fP *session)\fC [inline]\fP"

.PP
Definition at line 626 of file tb_listener\&.c\&.
.SS "int tb_set_epoll (\fBtb_listener_t\fP *listener)\fC [inline]\fP"

.PP
Set epoll for this listener\&. 
.PP
Definition at line 659 of file tb_listener\&.c\&.
.SS "void tb_set_l_stats (\fBtb_listener_t\fP *listener)"

.PP
Gets the stats for the listener\&. This method collects the stats for single connection servers\&. The stats are saved in the listener->stats field\&.
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to collect stats for\&. 
.RE
.PP

.PP
Definition at line 383 of file tb_listener\&.c\&.
.SS "void tb_set_m_stats (\fBtb_listener_t\fP *listener)"

.PP
Gets the stats for the listener\&. This method collects the stats for multiple connection servers\&. The stats are saved in each of the sessions stats structs, and the total number of bytes sent are saved in the listener->stats struct\&.
.PP
\fBPrecondition:\fP
.RS 4
The listener must be of the multiple connection type\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlistener\fP The listener to collect stats for\&. 
.RE
.PP

.PP
Definition at line 416 of file tb_listener\&.c\&.
.SS "int tb_setup_workers (\fBtb_listener_t\fP *listener, intnum_threads)"

.PP
Definition at line 232 of file tb_listener\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for TestBed from the source code\&.
