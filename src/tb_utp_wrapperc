/*
 * tb_utp_wrapper.c
 *
 *  Created on: 24/12/2013
 *      Author: michael
 */

//#include "tb_utp_wrapper.h"
#include "tb_utp.h"
#include "tb_testbed.h"
#include "tb_listener.h"
#include "tb_macro.h"

#include <utp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <errno.h>
#include <unistd.h>

static tb_utp_wrapper_t *wrapper = NULL;
static struct UTPFunctionTable *callbacks = NULL;

char animate[8] = {'|', '/', '-', '\\', '|', '/', '-', '\\'};
int a_index = 0;

int
tb_utp_setup(void *data)
{
	fprintf(stdout, "utp setup called\n");
	if(wrapper != NULL)
	{
		fprintf(stderr, "Wrapper already initalized\n");
		return -1;
	}

	wrapper = malloc(sizeof(tb_utp_wrapper_t));
	wrapper->socket = NULL;

	callbacks = malloc(sizeof(struct UTPFunctionTable));

	callbacks->on_read = &tb_utp_read,
	callbacks->on_write = &tb_utp_write,
	callbacks->get_rb_size = &tb_utp_get_Rcv_buff,
	callbacks->on_state = &tb_utp_state_change,
	callbacks->on_error = &tb_utp_error,
	callbacks->on_overhead = &tb_utp_overhead;

	wrapper->rec_buff_size = 8192;
	wrapper->rec_buffer = malloc(wrapper->rec_buff_size);

	wrapper->addr_len = (socklen_t)sizeof(struct sockaddr_storage);
	wrapper->addr_s = malloc(wrapper->addr_len);

	wrapper->is_server = 1;

	wrapper->e_id = -1;

	wrapper->recv_total = 0;

	wrapper->listener = (tb_listener_t*)data;

	return 0;
}

int
poll_for_events(int time)
{
	int rc;
	struct epoll_event *ret_events;

	if(wrapper->e_id == -1)
	{
		wrapper->e_id = epoll_create1(0);

		if(wrapper->e_id == -1)
		{
			perror("Cannot create epoll");
			return -1;
		}

		struct epoll_event event;

		event.events = EPOLLIN | EPOLLET;

		rc = epoll_ctl(wrapper->e_id, EPOLL_CTL_ADD, wrapper->sock_fd, &event);

		if(rc == -1)
		{
			perror("Cannot set epoll on socket");
			return -1;
		}
	}

	ret_events = calloc(64, sizeof(struct epoll_event));

	int i;

	int num_events = epoll_wait(wrapper->e_id, ret_events, 64, time);

	for(i = 0; i < num_events; i++)
	{
		if(ret_events[i].events & EPOLLIN){
			return 0;
		}
		else if(ret_events[1].events & EPOLLHUP)
		{
			return 1;
		}
		else
		{
			return -1;
		}
	}

	free(ret_events);

	return 1;
}

////////////////// Functions for uTP ///////////////////

void
tb_utp_read(void *userdata, const byte *bytes, size_t count)
{
	wrapper->read_bytes = count;
	wrapper->listener->total_tx_rx += count;

	memcpy(wrapper->rec_buffer, bytes, count);
}

void
tb_utp_write(void *userdata, byte *bytes, size_t count)
{
	memcpy(bytes, wrapper->buffer, count);
	wrapper->write_bytes += count;
	wrapper->listener->total_tx_rx += count;
}

size_t
tb_utp_get_Rcv_buff(void *userdata)
{
	return 0;
}

void
tb_utp_state_change(void *userdata, int state)
{
	wrapper->state = state;

	if(state == UTP_STATE_CONNECT)
	{
		wrapper->listener->status = TB_CONNECTED;
	}
}

void
tb_utp_error(void *userdata, int errcode)
{
	fprintf(stderr, "Error: tb_utp_error: %s\n", strerror(errcode));
	UTP_Close(wrapper->socket);
}

void
tb_utp_overhead(void *userdata, int send, size_t count, int type)
{

}

void
tb_utp_send_to(void *userdata, const byte *p, size_t len,
		const struct sockaddr *to, socklen_t tolen)
{
	int rc;

	rc = sendto(wrapper->sock_fd, p, len, 0, to, tolen);

	if(rc < 0)
	{
		perror("Error: tb_utp_send_to: send_to\n");
		exit(1);
	}
}

void
tb_utp_incoming(void *userdata, struct UTPSocket *socket)
{
	wrapper->socket = socket;
	UTP_SetSockopt(wrapper->socket, SO_RCVBUF, 100*300);
	UTP_SetCallbacks(wrapper->socket, callbacks, wrapper);
}
/////////////// Standard socket API //////////////////////

int
tb_utp_socket(int domain, int type, int protocol)
{
	fprintf(stdout, "utp_socket called\n");

	int rc;

	wrapper->sock_fd = socket(domain, type, protocol);

	if(wrapper->sock_fd == -1)
	{
		perror("Error: tb_utp_socket: socket");
		return -1;
	}

	int flags = fcntl(wrapper->sock_fd, F_GETFL, 0);

	if(flags == -1)
	{
		perror("Cannot get socket flags");
		return -1;
	}

	rc = fcntl(wrapper->sock_fd, F_SETFL, flags | O_NONBLOCK);

	if(rc == -1)
	{
		perror("Cannot set socket flags");
		return -1;
	}

	int size = 2 * 1024 * 1024;

	rc = setsockopt(wrapper->sock_fd, SOL_SOCKET, SO_RCVBUF,
			&size, sizeof(size));

	if(rc != 0)
	{
		perror("Cannot set socket RCVBUF\n");
		return -1;
	}

	rc = setsockopt(wrapper->sock_fd, SOL_SOCKET, SO_SNDBUF, &size,
			sizeof(size));

	if(rc != 0)
	{
		perror("Cannot set socket SNDBUF\n");
		return -1;
	}

	return wrapper->sock_fd;
}

int
tb_utp_connect(int fd, const struct sockaddr *addr, socklen_t len)
{
	assert(wrapper != NULL);

	int rc;

	rc = connect(fd, addr, len);

	if(rc != 0)
	{
		perror("Error: tb_utp_connect : connect");
		return -1;
	}

	wrapper->socket = UTP_Create(&tb_utp_send_to, wrapper, addr, len);
	UTP_SetSockopt(wrapper->socket, SO_SNDBUF, 100*300);

	assert(wrapper->socket != NULL);

	UTP_SetCallbacks(wrapper->socket, callbacks, wrapper->socket);
	UTP_Connect(wrapper->socket);

	wrapper->is_server = 0;

	return 0;
}

int
tb_utp_send(int fd, void *buf, size_t n, int sock_flags)
{
	int rc;

	wrapper->write_bytes = 0;
	wrapper->buffer = buf;
	wrapper->buffer_size = n;

	UTP_CheckTimeouts();

	if(wrapper->state == UTP_STATE_CONNECT ||
			wrapper->state == UTP_STATE_WRITABLE)
	{
		rc = UTP_Write(wrapper->socket, n);

		if(rc == 0)
		{
			wrapper->state = 0;
		}
	}
	else
	{
		rc = tb_utp_recv_data();

		if(rc < 0)
		{
			return -1;
		}
	}

	return wrapper->write_bytes;
}


int
tb_utp_recv_data()
{
	int p_ret, len = 0, rc;
	p_ret = poll_for_events(50);

	if(p_ret == 0)
	{
		do{
			len = recvfrom(wrapper->sock_fd, wrapper->rec_buffer,
							wrapper->rec_buff_size, 0,
							(struct sockaddr*)wrapper->addr_s, &wrapper->addr_len);

			if(len < 0)
			{
				int err_no = errno;

				if(err_no == ECONNRESET || err_no == EMSGSIZE)
				{
					continue;
				}

				if(err_no == EWOULDBLOCK)
				{
					return 0;
				}

				return -1;
			}

			rc = UTP_IsIncomingUTP(&tb_utp_incoming, &tb_utp_send_to, wrapper,
									(const byte*)wrapper->rec_buffer, (size_t)len,
									(const struct sockaddr*)wrapper->addr_s, wrapper->addr_len);

			if(rc == 0)
			{
				fprintf(stderr, "Error: utp_recv_from: UTP_IsIncoming\n");
				return -1;
			}
		}
		while(len > 0);
	}

	return len;
}

int
tb_utp_recv_from(int fd, void *buf, size_t n, unsigned int sock_flags,
		const struct sockaddr *to, socklen_t *tolen)
{
	int rc;
	wrapper->read_bytes = 0;

	rc = tb_utp_recv_data();
	UTP_CheckTimeouts();

	if(rc == -1)
	{
		return -1;
	}

	if(wrapper->state == UTP_STATE_EOF || wrapper->state == UTP_STATE_DESTROYING)
	{
		wrapper->read_bytes = -128;
	}

	return wrapper->read_bytes;
}

int
tb_utp_funct_exit()
{
	return 0;
}

int
tb_utp_error_handle(int value)
{
	return value;
}

int
tb_utp_options(int sock, int level, int opname, void *optval, int optlen)
{
	return 0;
}

int
tb_utp_close(int sock)
{
	fprintf(stdout, "Closing\n");
	UTP_Close(wrapper->socket);
	UTP_CheckTimeouts();

	while(wrapper->state != UTP_STATE_DESTROYING)
	{
		tb_utp_recv_data();
		UTP_CheckTimeouts();
	}

	close(wrapper->sock_fd);

	return 0;
}


